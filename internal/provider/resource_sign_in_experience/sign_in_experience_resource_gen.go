// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_sign_in_experience

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SignInExperienceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"agree_to_terms_policy": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"Automatic",
						"ManualRegistrationOnly",
						"Manual",
					),
				},
			},
			"branding": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dark_favicon": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"dark_logo_url": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"favicon": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"logo_url": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: BrandingType{
					ObjectType: types.ObjectType{
						AttrTypes: BrandingValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"captcha_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: CaptchaPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: CaptchaPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"color": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dark_primary_color": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("(?i)^#[\\da-f]{3}([\\da-f]{3})?$"), ""),
						},
					},
					"is_dark_mode_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"primary_color": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("(?i)^#[\\da-f]{3}([\\da-f]{3})?$"), ""),
						},
					},
				},
				CustomType: ColorType{
					ObjectType: types.ObjectType{
						AttrTypes: ColorValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Specify the primary branding color for the sign-in page (both light/dark mode).",
				MarkdownDescription: "Specify the primary branding color for the sign-in page (both light/dark mode).",
			},
			"custom_content": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.",
				MarkdownDescription: "Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.",
			},
			"custom_css": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"email_blocklist_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"block_disposable_addresses": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"block_subaddressing": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to block sub-addresses. (E.g., example+shopping@test.com)",
						MarkdownDescription: "Whether to block sub-addresses. (E.g., example+shopping@test.com)",
					},
					"custom_blocklist": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Custom blocklist of email addresses or domains.",
						MarkdownDescription: "Custom blocklist of email addresses or domains.",
					},
				},
				CustomType: EmailBlocklistPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: EmailBlocklistPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Define email restriction policies. Users will be prohibited from registering or linking any email addresses that are included in the blocklist.",
				MarkdownDescription: "Define email restriction policies. Users will be prohibited from registering or linking any email addresses that are included in the blocklist.",
			},
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"language_info": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_detect": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"fallback_language": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"af-ZA",
								"am-ET",
								"ar",
								"ar-AR",
								"as-IN",
								"az-AZ",
								"be-BY",
								"bg-BG",
								"bn-IN",
								"br-FR",
								"bs-BA",
								"ca-ES",
								"cb-IQ",
								"co-FR",
								"cs-CZ",
								"cx-PH",
								"cy-GB",
								"da-DK",
								"de",
								"de-DE",
								"el-GR",
								"en",
								"en-GB",
								"en-US",
								"eo-EO",
								"es",
								"es-ES",
								"es-419",
								"et-EE",
								"eu-ES",
								"fa-IR",
								"ff-NG",
								"fi",
								"fi-FI",
								"fo-FO",
								"fr",
								"fr-CA",
								"fr-FR",
								"fy-NL",
								"ga-IE",
								"gl-ES",
								"gn-PY",
								"gu-IN",
								"ha-NG",
								"he-IL",
								"hi-IN",
								"hr-HR",
								"ht-HT",
								"hu-HU",
								"hy-AM",
								"id-ID",
								"ik-US",
								"is-IS",
								"it",
								"it-IT",
								"iu-CA",
								"ja",
								"ja-JP",
								"ja-KS",
								"jv-ID",
								"ka-GE",
								"kk-KZ",
								"km-KH",
								"kn-IN",
								"ko",
								"ko-KR",
								"ku-TR",
								"ky-KG",
								"lo-LA",
								"lt-LT",
								"lv-LV",
								"mg-MG",
								"mk-MK",
								"ml-IN",
								"mn-MN",
								"mr-IN",
								"ms-MY",
								"mt-MT",
								"my-MM",
								"nb-NO",
								"ne-NP",
								"nl",
								"nl-BE",
								"nl-NL",
								"nn-NO",
								"or-IN",
								"pa-IN",
								"pl-PL",
								"ps-AF",
								"pt",
								"pt-BR",
								"pt-PT",
								"ro-RO",
								"ru",
								"ru-RU",
								"rw-RW",
								"sc-IT",
								"si-LK",
								"sk-SK",
								"sl-SI",
								"sn-ZW",
								"sq-AL",
								"sr-RS",
								"sv",
								"sv-SE",
								"sw-KE",
								"sy-SY",
								"sz-PL",
								"ta-IN",
								"te-IN",
								"tg-TJ",
								"th",
								"th-TH",
								"tl-PH",
								"tr",
								"tr-TR",
								"tt-RU",
								"tz-MA",
								"uk-UA",
								"ur-PK",
								"uz-UZ",
								"vi-VN",
								"zh",
								"zh-CN",
								"zh-HK",
								"zh-MO",
								"zh-TW",
								"zz-TR",
							),
						},
					},
				},
				CustomType: LanguageInfoType{
					ObjectType: types.ObjectType{
						AttrTypes: LanguageInfoValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Control the language detection policy for the sign-in page.",
				MarkdownDescription: "Control the language detection policy for the sign-in page.",
			},
			"mfa": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"factors": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"organization_required_mfa_policy": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"NoPrompt",
								"Mandatory",
							),
						},
					},
					"policy": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"UserControlled",
								"Mandatory",
								"PromptOnlyAtSignIn",
								"PromptAtSignInAndSignUp",
								"NoPrompt",
							),
						},
					},
				},
				CustomType: MfaType{
					ObjectType: types.ObjectType{
						AttrTypes: MfaValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "MFA settings",
				MarkdownDescription: "MFA settings",
			},
			"password_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"character_types": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"min": schema.NumberAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: CharacterTypesType{
							ObjectType: types.ObjectType{
								AttrTypes: CharacterTypesValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"length": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"max": schema.NumberAttribute{
								Optional: true,
								Computed: true,
							},
							"min": schema.NumberAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: LengthType{
							ObjectType: types.ObjectType{
								AttrTypes: LengthValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"rejects": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"pwned": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(true),
							},
							"repetition_and_sequence": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(true),
							},
							"user_info": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(true),
							},
							"words": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
							},
						},
						CustomType: RejectsType{
							ObjectType: types.ObjectType{
								AttrTypes: RejectsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: PasswordPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: PasswordPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Password policies to adjust the password strength requirements.",
				MarkdownDescription: "Password policies to adjust the password strength requirements.",
			},
			"privacy_policy_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(0, 2048),
				},
			},
			"sentinel_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"lockout_duration": schema.NumberAttribute{
						Optional: true,
						Computed: true,
					},
					"max_attempts": schema.NumberAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SentinelPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: SentinelPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Custom sentinel policy settings. Use this field to customize the user lockout policy. The default value is 100 failed attempts within one hour. The user will be locked out for 60 minutes after exceeding the limit.",
				MarkdownDescription: "Custom sentinel policy settings. Use this field to customize the user lockout policy. The default value is 100 failed attempts within one hour. The user will be locked out for 60 minutes after exceeding the limit.",
			},
			"sign_in": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"methods": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"identifier": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"username",
											"email",
											"phone",
										),
									},
								},
								"is_password_primary": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"password": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"verification_code": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: MethodsType{
								ObjectType: types.ObjectType{
									AttrTypes: MethodsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SignInType{
					ObjectType: types.ObjectType{
						AttrTypes: SignInValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Sign-in method settings",
				MarkdownDescription: "Sign-in method settings",
			},
			"sign_in_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"SignIn",
						"Register",
						"SignInAndRegister",
					),
				},
			},
			"sign_up": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"identifiers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Specify allowed identifiers when signing-up.",
						MarkdownDescription: "Specify allowed identifiers when signing-up.",
					},
					"password": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the user is required to set a password when signing-up.",
						MarkdownDescription: "Whether the user is required to set a password when signing-up.",
					},
					"secondary_identifiers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"identifier": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Specify a of identifiers.",
								MarkdownDescription: "Specify a of identifiers.",
							},
							"verify": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: SecondaryIdentifiersType{
							ObjectType: types.ObjectType{
								AttrTypes: SecondaryIdentifiersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Additional identifiers required during sign-up.",
						MarkdownDescription: "Additional identifiers required during sign-up.",
					},
					"verify": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the user is required to verify their email/phone when signing-up.",
						MarkdownDescription: "Whether the user is required to verify their email/phone when signing-up.",
					},
				},
				CustomType: SignUpType{
					ObjectType: types.ObjectType{
						AttrTypes: SignUpValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Sign-up method settings",
				MarkdownDescription: "Sign-up method settings",
			},
			"single_sign_on_enabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"social_sign_in": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"automatic_account_linking": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SocialSignInType{
					ObjectType: types.ObjectType{
						AttrTypes: SocialSignInValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"social_sign_in_connector_targets": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Specify the social sign-in connectors to display on the sign-in page.",
				MarkdownDescription: "Specify the social sign-in connectors to display on the sign-in page.",
			},
			"support_email": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"support_website_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"tenant_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(21),
				},
			},
			"terms_of_use_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(0, 2048),
				},
			},
			"unknown_session_redirect_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
		},
	}
}

type SignInExperienceModel struct {
	AgreeToTermsPolicy           types.String              `tfsdk:"agree_to_terms_policy"`
	Branding                     BrandingValue             `tfsdk:"branding"`
	CaptchaPolicy                CaptchaPolicyValue        `tfsdk:"captcha_policy"`
	Color                        ColorValue                `tfsdk:"color"`
	CustomContent                types.Map                 `tfsdk:"custom_content"`
	CustomCss                    types.String              `tfsdk:"custom_css"`
	EmailBlocklistPolicy         EmailBlocklistPolicyValue `tfsdk:"email_blocklist_policy"`
	Id                           types.String              `tfsdk:"id"`
	LanguageInfo                 LanguageInfoValue         `tfsdk:"language_info"`
	Mfa                          MfaValue                  `tfsdk:"mfa"`
	PasswordPolicy               PasswordPolicyValue       `tfsdk:"password_policy"`
	PrivacyPolicyUrl             types.String              `tfsdk:"privacy_policy_url"`
	SentinelPolicy               SentinelPolicyValue       `tfsdk:"sentinel_policy"`
	SignIn                       SignInValue               `tfsdk:"sign_in"`
	SignInMode                   types.String              `tfsdk:"sign_in_mode"`
	SignUp                       SignUpValue               `tfsdk:"sign_up"`
	SingleSignOnEnabled          types.Bool                `tfsdk:"single_sign_on_enabled"`
	SocialSignIn                 SocialSignInValue         `tfsdk:"social_sign_in"`
	SocialSignInConnectorTargets types.List                `tfsdk:"social_sign_in_connector_targets"`
	SupportEmail                 types.String              `tfsdk:"support_email"`
	SupportWebsiteUrl            types.String              `tfsdk:"support_website_url"`
	TenantId                     types.String              `tfsdk:"tenant_id"`
	TermsOfUseUrl                types.String              `tfsdk:"terms_of_use_url"`
	UnknownSessionRedirectUrl    types.String              `tfsdk:"unknown_session_redirect_url"`
}

var _ basetypes.ObjectTypable = BrandingType{}

type BrandingType struct {
	basetypes.ObjectType
}

func (t BrandingType) Equal(o attr.Type) bool {
	other, ok := o.(BrandingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BrandingType) String() string {
	return "BrandingType"
}

func (t BrandingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	darkFaviconAttribute, ok := attributes["dark_favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_favicon is missing from object`)

		return nil, diags
	}

	darkFaviconVal, ok := darkFaviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_favicon expected to be basetypes.StringValue, was: %T`, darkFaviconAttribute))
	}

	darkLogoUrlAttribute, ok := attributes["dark_logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_logo_url is missing from object`)

		return nil, diags
	}

	darkLogoUrlVal, ok := darkLogoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_logo_url expected to be basetypes.StringValue, was: %T`, darkLogoUrlAttribute))
	}

	faviconAttribute, ok := attributes["favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`favicon is missing from object`)

		return nil, diags
	}

	faviconVal, ok := faviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`favicon expected to be basetypes.StringValue, was: %T`, faviconAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return nil, diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BrandingValue{
		DarkFavicon: darkFaviconVal,
		DarkLogoUrl: darkLogoUrlVal,
		Favicon:     faviconVal,
		LogoUrl:     logoUrlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBrandingValueNull() BrandingValue {
	return BrandingValue{
		state: attr.ValueStateNull,
	}
}

func NewBrandingValueUnknown() BrandingValue {
	return BrandingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBrandingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BrandingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BrandingValue Attribute Value",
				"While creating a BrandingValue value, a missing attribute value was detected. "+
					"A BrandingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrandingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BrandingValue Attribute Type",
				"While creating a BrandingValue value, an invalid attribute value was detected. "+
					"A BrandingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrandingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BrandingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BrandingValue Attribute Value",
				"While creating a BrandingValue value, an extra attribute value was detected. "+
					"A BrandingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BrandingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBrandingValueUnknown(), diags
	}

	darkFaviconAttribute, ok := attributes["dark_favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_favicon is missing from object`)

		return NewBrandingValueUnknown(), diags
	}

	darkFaviconVal, ok := darkFaviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_favicon expected to be basetypes.StringValue, was: %T`, darkFaviconAttribute))
	}

	darkLogoUrlAttribute, ok := attributes["dark_logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_logo_url is missing from object`)

		return NewBrandingValueUnknown(), diags
	}

	darkLogoUrlVal, ok := darkLogoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_logo_url expected to be basetypes.StringValue, was: %T`, darkLogoUrlAttribute))
	}

	faviconAttribute, ok := attributes["favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`favicon is missing from object`)

		return NewBrandingValueUnknown(), diags
	}

	faviconVal, ok := faviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`favicon expected to be basetypes.StringValue, was: %T`, faviconAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return NewBrandingValueUnknown(), diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	if diags.HasError() {
		return NewBrandingValueUnknown(), diags
	}

	return BrandingValue{
		DarkFavicon: darkFaviconVal,
		DarkLogoUrl: darkLogoUrlVal,
		Favicon:     faviconVal,
		LogoUrl:     logoUrlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBrandingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BrandingValue {
	object, diags := NewBrandingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBrandingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BrandingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBrandingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBrandingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBrandingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBrandingValueMust(BrandingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BrandingType) ValueType(ctx context.Context) attr.Value {
	return BrandingValue{}
}

var _ basetypes.ObjectValuable = BrandingValue{}

type BrandingValue struct {
	DarkFavicon basetypes.StringValue `tfsdk:"dark_favicon"`
	DarkLogoUrl basetypes.StringValue `tfsdk:"dark_logo_url"`
	Favicon     basetypes.StringValue `tfsdk:"favicon"`
	LogoUrl     basetypes.StringValue `tfsdk:"logo_url"`
	state       attr.ValueState
}

func (v BrandingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["dark_favicon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dark_logo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["favicon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["logo_url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DarkFavicon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dark_favicon"] = val

		val, err = v.DarkLogoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dark_logo_url"] = val

		val, err = v.Favicon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["favicon"] = val

		val, err = v.LogoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["logo_url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BrandingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BrandingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BrandingValue) String() string {
	return "BrandingValue"
}

func (v BrandingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dark_favicon":  basetypes.StringType{},
		"dark_logo_url": basetypes.StringType{},
		"favicon":       basetypes.StringType{},
		"logo_url":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dark_favicon":  v.DarkFavicon,
			"dark_logo_url": v.DarkLogoUrl,
			"favicon":       v.Favicon,
			"logo_url":      v.LogoUrl,
		})

	return objVal, diags
}

func (v BrandingValue) Equal(o attr.Value) bool {
	other, ok := o.(BrandingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DarkFavicon.Equal(other.DarkFavicon) {
		return false
	}

	if !v.DarkLogoUrl.Equal(other.DarkLogoUrl) {
		return false
	}

	if !v.Favicon.Equal(other.Favicon) {
		return false
	}

	if !v.LogoUrl.Equal(other.LogoUrl) {
		return false
	}

	return true
}

func (v BrandingValue) Type(ctx context.Context) attr.Type {
	return BrandingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BrandingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dark_favicon":  basetypes.StringType{},
		"dark_logo_url": basetypes.StringType{},
		"favicon":       basetypes.StringType{},
		"logo_url":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CaptchaPolicyType{}

type CaptchaPolicyType struct {
	basetypes.ObjectType
}

func (t CaptchaPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(CaptchaPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CaptchaPolicyType) String() string {
	return "CaptchaPolicyType"
}

func (t CaptchaPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CaptchaPolicyValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCaptchaPolicyValueNull() CaptchaPolicyValue {
	return CaptchaPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewCaptchaPolicyValueUnknown() CaptchaPolicyValue {
	return CaptchaPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCaptchaPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CaptchaPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CaptchaPolicyValue Attribute Value",
				"While creating a CaptchaPolicyValue value, a missing attribute value was detected. "+
					"A CaptchaPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CaptchaPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CaptchaPolicyValue Attribute Type",
				"While creating a CaptchaPolicyValue value, an invalid attribute value was detected. "+
					"A CaptchaPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CaptchaPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CaptchaPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CaptchaPolicyValue Attribute Value",
				"While creating a CaptchaPolicyValue value, an extra attribute value was detected. "+
					"A CaptchaPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CaptchaPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCaptchaPolicyValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCaptchaPolicyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewCaptchaPolicyValueUnknown(), diags
	}

	return CaptchaPolicyValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCaptchaPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CaptchaPolicyValue {
	object, diags := NewCaptchaPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCaptchaPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CaptchaPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCaptchaPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCaptchaPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCaptchaPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCaptchaPolicyValueMust(CaptchaPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CaptchaPolicyType) ValueType(ctx context.Context) attr.Value {
	return CaptchaPolicyValue{}
}

var _ basetypes.ObjectValuable = CaptchaPolicyValue{}

type CaptchaPolicyValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v CaptchaPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CaptchaPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CaptchaPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CaptchaPolicyValue) String() string {
	return "CaptchaPolicyValue"
}

func (v CaptchaPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v CaptchaPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(CaptchaPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v CaptchaPolicyValue) Type(ctx context.Context) attr.Type {
	return CaptchaPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CaptchaPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ColorType{}

type ColorType struct {
	basetypes.ObjectType
}

func (t ColorType) Equal(o attr.Type) bool {
	other, ok := o.(ColorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ColorType) String() string {
	return "ColorType"
}

func (t ColorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	darkPrimaryColorAttribute, ok := attributes["dark_primary_color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_primary_color is missing from object`)

		return nil, diags
	}

	darkPrimaryColorVal, ok := darkPrimaryColorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_primary_color expected to be basetypes.StringValue, was: %T`, darkPrimaryColorAttribute))
	}

	isDarkModeEnabledAttribute, ok := attributes["is_dark_mode_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_dark_mode_enabled is missing from object`)

		return nil, diags
	}

	isDarkModeEnabledVal, ok := isDarkModeEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_dark_mode_enabled expected to be basetypes.BoolValue, was: %T`, isDarkModeEnabledAttribute))
	}

	primaryColorAttribute, ok := attributes["primary_color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_color is missing from object`)

		return nil, diags
	}

	primaryColorVal, ok := primaryColorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_color expected to be basetypes.StringValue, was: %T`, primaryColorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ColorValue{
		DarkPrimaryColor:  darkPrimaryColorVal,
		IsDarkModeEnabled: isDarkModeEnabledVal,
		PrimaryColor:      primaryColorVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewColorValueNull() ColorValue {
	return ColorValue{
		state: attr.ValueStateNull,
	}
}

func NewColorValueUnknown() ColorValue {
	return ColorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewColorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ColorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ColorValue Attribute Value",
				"While creating a ColorValue value, a missing attribute value was detected. "+
					"A ColorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ColorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ColorValue Attribute Type",
				"While creating a ColorValue value, an invalid attribute value was detected. "+
					"A ColorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ColorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ColorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ColorValue Attribute Value",
				"While creating a ColorValue value, an extra attribute value was detected. "+
					"A ColorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ColorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewColorValueUnknown(), diags
	}

	darkPrimaryColorAttribute, ok := attributes["dark_primary_color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dark_primary_color is missing from object`)

		return NewColorValueUnknown(), diags
	}

	darkPrimaryColorVal, ok := darkPrimaryColorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dark_primary_color expected to be basetypes.StringValue, was: %T`, darkPrimaryColorAttribute))
	}

	isDarkModeEnabledAttribute, ok := attributes["is_dark_mode_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_dark_mode_enabled is missing from object`)

		return NewColorValueUnknown(), diags
	}

	isDarkModeEnabledVal, ok := isDarkModeEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_dark_mode_enabled expected to be basetypes.BoolValue, was: %T`, isDarkModeEnabledAttribute))
	}

	primaryColorAttribute, ok := attributes["primary_color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_color is missing from object`)

		return NewColorValueUnknown(), diags
	}

	primaryColorVal, ok := primaryColorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_color expected to be basetypes.StringValue, was: %T`, primaryColorAttribute))
	}

	if diags.HasError() {
		return NewColorValueUnknown(), diags
	}

	return ColorValue{
		DarkPrimaryColor:  darkPrimaryColorVal,
		IsDarkModeEnabled: isDarkModeEnabledVal,
		PrimaryColor:      primaryColorVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewColorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ColorValue {
	object, diags := NewColorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewColorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ColorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewColorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewColorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewColorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewColorValueMust(ColorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ColorType) ValueType(ctx context.Context) attr.Value {
	return ColorValue{}
}

var _ basetypes.ObjectValuable = ColorValue{}

type ColorValue struct {
	DarkPrimaryColor  basetypes.StringValue `tfsdk:"dark_primary_color"`
	IsDarkModeEnabled basetypes.BoolValue   `tfsdk:"is_dark_mode_enabled"`
	PrimaryColor      basetypes.StringValue `tfsdk:"primary_color"`
	state             attr.ValueState
}

func (v ColorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dark_primary_color"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_dark_mode_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["primary_color"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DarkPrimaryColor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dark_primary_color"] = val

		val, err = v.IsDarkModeEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_dark_mode_enabled"] = val

		val, err = v.PrimaryColor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary_color"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ColorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ColorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ColorValue) String() string {
	return "ColorValue"
}

func (v ColorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dark_primary_color":   basetypes.StringType{},
		"is_dark_mode_enabled": basetypes.BoolType{},
		"primary_color":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dark_primary_color":   v.DarkPrimaryColor,
			"is_dark_mode_enabled": v.IsDarkModeEnabled,
			"primary_color":        v.PrimaryColor,
		})

	return objVal, diags
}

func (v ColorValue) Equal(o attr.Value) bool {
	other, ok := o.(ColorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DarkPrimaryColor.Equal(other.DarkPrimaryColor) {
		return false
	}

	if !v.IsDarkModeEnabled.Equal(other.IsDarkModeEnabled) {
		return false
	}

	if !v.PrimaryColor.Equal(other.PrimaryColor) {
		return false
	}

	return true
}

func (v ColorValue) Type(ctx context.Context) attr.Type {
	return ColorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ColorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dark_primary_color":   basetypes.StringType{},
		"is_dark_mode_enabled": basetypes.BoolType{},
		"primary_color":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EmailBlocklistPolicyType{}

type EmailBlocklistPolicyType struct {
	basetypes.ObjectType
}

func (t EmailBlocklistPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(EmailBlocklistPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EmailBlocklistPolicyType) String() string {
	return "EmailBlocklistPolicyType"
}

func (t EmailBlocklistPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	blockDisposableAddressesAttribute, ok := attributes["block_disposable_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_disposable_addresses is missing from object`)

		return nil, diags
	}

	blockDisposableAddressesVal, ok := blockDisposableAddressesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_disposable_addresses expected to be basetypes.BoolValue, was: %T`, blockDisposableAddressesAttribute))
	}

	blockSubaddressingAttribute, ok := attributes["block_subaddressing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_subaddressing is missing from object`)

		return nil, diags
	}

	blockSubaddressingVal, ok := blockSubaddressingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_subaddressing expected to be basetypes.BoolValue, was: %T`, blockSubaddressingAttribute))
	}

	customBlocklistAttribute, ok := attributes["custom_blocklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_blocklist is missing from object`)

		return nil, diags
	}

	customBlocklistVal, ok := customBlocklistAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_blocklist expected to be basetypes.ListValue, was: %T`, customBlocklistAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EmailBlocklistPolicyValue{
		BlockDisposableAddresses: blockDisposableAddressesVal,
		BlockSubaddressing:       blockSubaddressingVal,
		CustomBlocklist:          customBlocklistVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewEmailBlocklistPolicyValueNull() EmailBlocklistPolicyValue {
	return EmailBlocklistPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewEmailBlocklistPolicyValueUnknown() EmailBlocklistPolicyValue {
	return EmailBlocklistPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEmailBlocklistPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EmailBlocklistPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EmailBlocklistPolicyValue Attribute Value",
				"While creating a EmailBlocklistPolicyValue value, a missing attribute value was detected. "+
					"A EmailBlocklistPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailBlocklistPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EmailBlocklistPolicyValue Attribute Type",
				"While creating a EmailBlocklistPolicyValue value, an invalid attribute value was detected. "+
					"A EmailBlocklistPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailBlocklistPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EmailBlocklistPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EmailBlocklistPolicyValue Attribute Value",
				"While creating a EmailBlocklistPolicyValue value, an extra attribute value was detected. "+
					"A EmailBlocklistPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EmailBlocklistPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEmailBlocklistPolicyValueUnknown(), diags
	}

	blockDisposableAddressesAttribute, ok := attributes["block_disposable_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_disposable_addresses is missing from object`)

		return NewEmailBlocklistPolicyValueUnknown(), diags
	}

	blockDisposableAddressesVal, ok := blockDisposableAddressesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_disposable_addresses expected to be basetypes.BoolValue, was: %T`, blockDisposableAddressesAttribute))
	}

	blockSubaddressingAttribute, ok := attributes["block_subaddressing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_subaddressing is missing from object`)

		return NewEmailBlocklistPolicyValueUnknown(), diags
	}

	blockSubaddressingVal, ok := blockSubaddressingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_subaddressing expected to be basetypes.BoolValue, was: %T`, blockSubaddressingAttribute))
	}

	customBlocklistAttribute, ok := attributes["custom_blocklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_blocklist is missing from object`)

		return NewEmailBlocklistPolicyValueUnknown(), diags
	}

	customBlocklistVal, ok := customBlocklistAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_blocklist expected to be basetypes.ListValue, was: %T`, customBlocklistAttribute))
	}

	if diags.HasError() {
		return NewEmailBlocklistPolicyValueUnknown(), diags
	}

	return EmailBlocklistPolicyValue{
		BlockDisposableAddresses: blockDisposableAddressesVal,
		BlockSubaddressing:       blockSubaddressingVal,
		CustomBlocklist:          customBlocklistVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewEmailBlocklistPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EmailBlocklistPolicyValue {
	object, diags := NewEmailBlocklistPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEmailBlocklistPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EmailBlocklistPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEmailBlocklistPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEmailBlocklistPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEmailBlocklistPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEmailBlocklistPolicyValueMust(EmailBlocklistPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EmailBlocklistPolicyType) ValueType(ctx context.Context) attr.Value {
	return EmailBlocklistPolicyValue{}
}

var _ basetypes.ObjectValuable = EmailBlocklistPolicyValue{}

type EmailBlocklistPolicyValue struct {
	BlockDisposableAddresses basetypes.BoolValue `tfsdk:"block_disposable_addresses"`
	BlockSubaddressing       basetypes.BoolValue `tfsdk:"block_subaddressing"`
	CustomBlocklist          basetypes.ListValue `tfsdk:"custom_blocklist"`
	state                    attr.ValueState
}

func (v EmailBlocklistPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["block_disposable_addresses"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_subaddressing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["custom_blocklist"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BlockDisposableAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_disposable_addresses"] = val

		val, err = v.BlockSubaddressing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_subaddressing"] = val

		val, err = v.CustomBlocklist.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_blocklist"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EmailBlocklistPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EmailBlocklistPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EmailBlocklistPolicyValue) String() string {
	return "EmailBlocklistPolicyValue"
}

func (v EmailBlocklistPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customBlocklistVal basetypes.ListValue
	switch {
	case v.CustomBlocklist.IsUnknown():
		customBlocklistVal = types.ListUnknown(types.StringType)
	case v.CustomBlocklist.IsNull():
		customBlocklistVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		customBlocklistVal, d = types.ListValue(types.StringType, v.CustomBlocklist.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"block_disposable_addresses": basetypes.BoolType{},
			"block_subaddressing":        basetypes.BoolType{},
			"custom_blocklist": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"block_disposable_addresses": basetypes.BoolType{},
		"block_subaddressing":        basetypes.BoolType{},
		"custom_blocklist": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"block_disposable_addresses": v.BlockDisposableAddresses,
			"block_subaddressing":        v.BlockSubaddressing,
			"custom_blocklist":           customBlocklistVal,
		})

	return objVal, diags
}

func (v EmailBlocklistPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(EmailBlocklistPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BlockDisposableAddresses.Equal(other.BlockDisposableAddresses) {
		return false
	}

	if !v.BlockSubaddressing.Equal(other.BlockSubaddressing) {
		return false
	}

	if !v.CustomBlocklist.Equal(other.CustomBlocklist) {
		return false
	}

	return true
}

func (v EmailBlocklistPolicyValue) Type(ctx context.Context) attr.Type {
	return EmailBlocklistPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EmailBlocklistPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"block_disposable_addresses": basetypes.BoolType{},
		"block_subaddressing":        basetypes.BoolType{},
		"custom_blocklist": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = LanguageInfoType{}

type LanguageInfoType struct {
	basetypes.ObjectType
}

func (t LanguageInfoType) Equal(o attr.Type) bool {
	other, ok := o.(LanguageInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LanguageInfoType) String() string {
	return "LanguageInfoType"
}

func (t LanguageInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoDetectAttribute, ok := attributes["auto_detect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_detect is missing from object`)

		return nil, diags
	}

	autoDetectVal, ok := autoDetectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_detect expected to be basetypes.BoolValue, was: %T`, autoDetectAttribute))
	}

	fallbackLanguageAttribute, ok := attributes["fallback_language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fallback_language is missing from object`)

		return nil, diags
	}

	fallbackLanguageVal, ok := fallbackLanguageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fallback_language expected to be basetypes.StringValue, was: %T`, fallbackLanguageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LanguageInfoValue{
		AutoDetect:       autoDetectVal,
		FallbackLanguage: fallbackLanguageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLanguageInfoValueNull() LanguageInfoValue {
	return LanguageInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewLanguageInfoValueUnknown() LanguageInfoValue {
	return LanguageInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLanguageInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LanguageInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LanguageInfoValue Attribute Value",
				"While creating a LanguageInfoValue value, a missing attribute value was detected. "+
					"A LanguageInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LanguageInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LanguageInfoValue Attribute Type",
				"While creating a LanguageInfoValue value, an invalid attribute value was detected. "+
					"A LanguageInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LanguageInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LanguageInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LanguageInfoValue Attribute Value",
				"While creating a LanguageInfoValue value, an extra attribute value was detected. "+
					"A LanguageInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LanguageInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLanguageInfoValueUnknown(), diags
	}

	autoDetectAttribute, ok := attributes["auto_detect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_detect is missing from object`)

		return NewLanguageInfoValueUnknown(), diags
	}

	autoDetectVal, ok := autoDetectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_detect expected to be basetypes.BoolValue, was: %T`, autoDetectAttribute))
	}

	fallbackLanguageAttribute, ok := attributes["fallback_language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fallback_language is missing from object`)

		return NewLanguageInfoValueUnknown(), diags
	}

	fallbackLanguageVal, ok := fallbackLanguageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fallback_language expected to be basetypes.StringValue, was: %T`, fallbackLanguageAttribute))
	}

	if diags.HasError() {
		return NewLanguageInfoValueUnknown(), diags
	}

	return LanguageInfoValue{
		AutoDetect:       autoDetectVal,
		FallbackLanguage: fallbackLanguageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLanguageInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LanguageInfoValue {
	object, diags := NewLanguageInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLanguageInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LanguageInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLanguageInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLanguageInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLanguageInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLanguageInfoValueMust(LanguageInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LanguageInfoType) ValueType(ctx context.Context) attr.Value {
	return LanguageInfoValue{}
}

var _ basetypes.ObjectValuable = LanguageInfoValue{}

type LanguageInfoValue struct {
	AutoDetect       basetypes.BoolValue   `tfsdk:"auto_detect"`
	FallbackLanguage basetypes.StringValue `tfsdk:"fallback_language"`
	state            attr.ValueState
}

func (v LanguageInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["auto_detect"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fallback_language"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AutoDetect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_detect"] = val

		val, err = v.FallbackLanguage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fallback_language"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LanguageInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LanguageInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LanguageInfoValue) String() string {
	return "LanguageInfoValue"
}

func (v LanguageInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_detect":       basetypes.BoolType{},
		"fallback_language": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_detect":       v.AutoDetect,
			"fallback_language": v.FallbackLanguage,
		})

	return objVal, diags
}

func (v LanguageInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(LanguageInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoDetect.Equal(other.AutoDetect) {
		return false
	}

	if !v.FallbackLanguage.Equal(other.FallbackLanguage) {
		return false
	}

	return true
}

func (v LanguageInfoValue) Type(ctx context.Context) attr.Type {
	return LanguageInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LanguageInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_detect":       basetypes.BoolType{},
		"fallback_language": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MfaType{}

type MfaType struct {
	basetypes.ObjectType
}

func (t MfaType) Equal(o attr.Type) bool {
	other, ok := o.(MfaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MfaType) String() string {
	return "MfaType"
}

func (t MfaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	factorsAttribute, ok := attributes["factors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factors is missing from object`)

		return nil, diags
	}

	factorsVal, ok := factorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factors expected to be basetypes.ListValue, was: %T`, factorsAttribute))
	}

	organizationRequiredMfaPolicyAttribute, ok := attributes["organization_required_mfa_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_required_mfa_policy is missing from object`)

		return nil, diags
	}

	organizationRequiredMfaPolicyVal, ok := organizationRequiredMfaPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_required_mfa_policy expected to be basetypes.StringValue, was: %T`, organizationRequiredMfaPolicyAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return nil, diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MfaValue{
		Factors:                       factorsVal,
		OrganizationRequiredMfaPolicy: organizationRequiredMfaPolicyVal,
		Policy:                        policyVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewMfaValueNull() MfaValue {
	return MfaValue{
		state: attr.ValueStateNull,
	}
}

func NewMfaValueUnknown() MfaValue {
	return MfaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMfaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MfaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MfaValue Attribute Value",
				"While creating a MfaValue value, a missing attribute value was detected. "+
					"A MfaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MfaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MfaValue Attribute Type",
				"While creating a MfaValue value, an invalid attribute value was detected. "+
					"A MfaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MfaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MfaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MfaValue Attribute Value",
				"While creating a MfaValue value, an extra attribute value was detected. "+
					"A MfaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MfaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMfaValueUnknown(), diags
	}

	factorsAttribute, ok := attributes["factors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factors is missing from object`)

		return NewMfaValueUnknown(), diags
	}

	factorsVal, ok := factorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factors expected to be basetypes.ListValue, was: %T`, factorsAttribute))
	}

	organizationRequiredMfaPolicyAttribute, ok := attributes["organization_required_mfa_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_required_mfa_policy is missing from object`)

		return NewMfaValueUnknown(), diags
	}

	organizationRequiredMfaPolicyVal, ok := organizationRequiredMfaPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_required_mfa_policy expected to be basetypes.StringValue, was: %T`, organizationRequiredMfaPolicyAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return NewMfaValueUnknown(), diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	if diags.HasError() {
		return NewMfaValueUnknown(), diags
	}

	return MfaValue{
		Factors:                       factorsVal,
		OrganizationRequiredMfaPolicy: organizationRequiredMfaPolicyVal,
		Policy:                        policyVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewMfaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MfaValue {
	object, diags := NewMfaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMfaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MfaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMfaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMfaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMfaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMfaValueMust(MfaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MfaType) ValueType(ctx context.Context) attr.Value {
	return MfaValue{}
}

var _ basetypes.ObjectValuable = MfaValue{}

type MfaValue struct {
	Factors                       basetypes.ListValue   `tfsdk:"factors"`
	OrganizationRequiredMfaPolicy basetypes.StringValue `tfsdk:"organization_required_mfa_policy"`
	Policy                        basetypes.StringValue `tfsdk:"policy"`
	state                         attr.ValueState
}

func (v MfaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["factors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["organization_required_mfa_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Factors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["factors"] = val

		val, err = v.OrganizationRequiredMfaPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_required_mfa_policy"] = val

		val, err = v.Policy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MfaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MfaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MfaValue) String() string {
	return "MfaValue"
}

func (v MfaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var factorsVal basetypes.ListValue
	switch {
	case v.Factors.IsUnknown():
		factorsVal = types.ListUnknown(types.StringType)
	case v.Factors.IsNull():
		factorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		factorsVal, d = types.ListValue(types.StringType, v.Factors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"factors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"organization_required_mfa_policy": basetypes.StringType{},
			"policy":                           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"factors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"organization_required_mfa_policy": basetypes.StringType{},
		"policy":                           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"factors":                          factorsVal,
			"organization_required_mfa_policy": v.OrganizationRequiredMfaPolicy,
			"policy":                           v.Policy,
		})

	return objVal, diags
}

func (v MfaValue) Equal(o attr.Value) bool {
	other, ok := o.(MfaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Factors.Equal(other.Factors) {
		return false
	}

	if !v.OrganizationRequiredMfaPolicy.Equal(other.OrganizationRequiredMfaPolicy) {
		return false
	}

	if !v.Policy.Equal(other.Policy) {
		return false
	}

	return true
}

func (v MfaValue) Type(ctx context.Context) attr.Type {
	return MfaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MfaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"factors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"organization_required_mfa_policy": basetypes.StringType{},
		"policy":                           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PasswordPolicyType{}

type PasswordPolicyType struct {
	basetypes.ObjectType
}

func (t PasswordPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(PasswordPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PasswordPolicyType) String() string {
	return "PasswordPolicyType"
}

func (t PasswordPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	characterTypesAttribute, ok := attributes["character_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`character_types is missing from object`)

		return nil, diags
	}

	characterTypesVal, ok := characterTypesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`character_types expected to be basetypes.ObjectValue, was: %T`, characterTypesAttribute))
	}

	lengthAttribute, ok := attributes["length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`length is missing from object`)

		return nil, diags
	}

	lengthVal, ok := lengthAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`length expected to be basetypes.ObjectValue, was: %T`, lengthAttribute))
	}

	rejectsAttribute, ok := attributes["rejects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejects is missing from object`)

		return nil, diags
	}

	rejectsVal, ok := rejectsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejects expected to be basetypes.ObjectValue, was: %T`, rejectsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PasswordPolicyValue{
		CharacterTypes: characterTypesVal,
		Length:         lengthVal,
		Rejects:        rejectsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueNull() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewPasswordPolicyValueUnknown() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPasswordPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PasswordPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, a missing attribute value was detected. "+
					"A PasswordPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PasswordPolicyValue Attribute Type",
				"While creating a PasswordPolicyValue value, an invalid attribute value was detected. "+
					"A PasswordPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, an extra attribute value was detected. "+
					"A PasswordPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PasswordPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	characterTypesAttribute, ok := attributes["character_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`character_types is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	characterTypesVal, ok := characterTypesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`character_types expected to be basetypes.ObjectValue, was: %T`, characterTypesAttribute))
	}

	lengthAttribute, ok := attributes["length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`length is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	lengthVal, ok := lengthAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`length expected to be basetypes.ObjectValue, was: %T`, lengthAttribute))
	}

	rejectsAttribute, ok := attributes["rejects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejects is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	rejectsVal, ok := rejectsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejects expected to be basetypes.ObjectValue, was: %T`, rejectsAttribute))
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	return PasswordPolicyValue{
		CharacterTypes: characterTypesVal,
		Length:         lengthVal,
		Rejects:        rejectsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PasswordPolicyValue {
	object, diags := NewPasswordPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPasswordPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PasswordPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPasswordPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPasswordPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPasswordPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPasswordPolicyValueMust(PasswordPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PasswordPolicyType) ValueType(ctx context.Context) attr.Value {
	return PasswordPolicyValue{}
}

var _ basetypes.ObjectValuable = PasswordPolicyValue{}

type PasswordPolicyValue struct {
	CharacterTypes basetypes.ObjectValue `tfsdk:"character_types"`
	Length         basetypes.ObjectValue `tfsdk:"length"`
	Rejects        basetypes.ObjectValue `tfsdk:"rejects"`
	state          attr.ValueState
}

func (v PasswordPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["character_types"] = basetypes.ObjectType{
		AttrTypes: CharacterTypesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["length"] = basetypes.ObjectType{
		AttrTypes: LengthValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rejects"] = basetypes.ObjectType{
		AttrTypes: RejectsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CharacterTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["character_types"] = val

		val, err = v.Length.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["length"] = val

		val, err = v.Rejects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rejects"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PasswordPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PasswordPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PasswordPolicyValue) String() string {
	return "PasswordPolicyValue"
}

func (v PasswordPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var characterTypes basetypes.ObjectValue

	if v.CharacterTypes.IsNull() {
		characterTypes = types.ObjectNull(
			CharacterTypesValue{}.AttributeTypes(ctx),
		)
	}

	if v.CharacterTypes.IsUnknown() {
		characterTypes = types.ObjectUnknown(
			CharacterTypesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CharacterTypes.IsNull() && !v.CharacterTypes.IsUnknown() {
		characterTypes = types.ObjectValueMust(
			CharacterTypesValue{}.AttributeTypes(ctx),
			v.CharacterTypes.Attributes(),
		)
	}

	var length basetypes.ObjectValue

	if v.Length.IsNull() {
		length = types.ObjectNull(
			LengthValue{}.AttributeTypes(ctx),
		)
	}

	if v.Length.IsUnknown() {
		length = types.ObjectUnknown(
			LengthValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Length.IsNull() && !v.Length.IsUnknown() {
		length = types.ObjectValueMust(
			LengthValue{}.AttributeTypes(ctx),
			v.Length.Attributes(),
		)
	}

	var rejects basetypes.ObjectValue

	if v.Rejects.IsNull() {
		rejects = types.ObjectNull(
			RejectsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Rejects.IsUnknown() {
		rejects = types.ObjectUnknown(
			RejectsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Rejects.IsNull() && !v.Rejects.IsUnknown() {
		rejects = types.ObjectValueMust(
			RejectsValue{}.AttributeTypes(ctx),
			v.Rejects.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"character_types": basetypes.ObjectType{
			AttrTypes: CharacterTypesValue{}.AttributeTypes(ctx),
		},
		"length": basetypes.ObjectType{
			AttrTypes: LengthValue{}.AttributeTypes(ctx),
		},
		"rejects": basetypes.ObjectType{
			AttrTypes: RejectsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"character_types": characterTypes,
			"length":          length,
			"rejects":         rejects,
		})

	return objVal, diags
}

func (v PasswordPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(PasswordPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CharacterTypes.Equal(other.CharacterTypes) {
		return false
	}

	if !v.Length.Equal(other.Length) {
		return false
	}

	if !v.Rejects.Equal(other.Rejects) {
		return false
	}

	return true
}

func (v PasswordPolicyValue) Type(ctx context.Context) attr.Type {
	return PasswordPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PasswordPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"character_types": basetypes.ObjectType{
			AttrTypes: CharacterTypesValue{}.AttributeTypes(ctx),
		},
		"length": basetypes.ObjectType{
			AttrTypes: LengthValue{}.AttributeTypes(ctx),
		},
		"rejects": basetypes.ObjectType{
			AttrTypes: RejectsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CharacterTypesType{}

type CharacterTypesType struct {
	basetypes.ObjectType
}

func (t CharacterTypesType) Equal(o attr.Type) bool {
	other, ok := o.(CharacterTypesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CharacterTypesType) String() string {
	return "CharacterTypesType"
}

func (t CharacterTypesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.NumberValue, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CharacterTypesValue{
		Min:   minVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCharacterTypesValueNull() CharacterTypesValue {
	return CharacterTypesValue{
		state: attr.ValueStateNull,
	}
}

func NewCharacterTypesValueUnknown() CharacterTypesValue {
	return CharacterTypesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCharacterTypesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CharacterTypesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CharacterTypesValue Attribute Value",
				"While creating a CharacterTypesValue value, a missing attribute value was detected. "+
					"A CharacterTypesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CharacterTypesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CharacterTypesValue Attribute Type",
				"While creating a CharacterTypesValue value, an invalid attribute value was detected. "+
					"A CharacterTypesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CharacterTypesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CharacterTypesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CharacterTypesValue Attribute Value",
				"While creating a CharacterTypesValue value, an extra attribute value was detected. "+
					"A CharacterTypesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CharacterTypesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCharacterTypesValueUnknown(), diags
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewCharacterTypesValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.NumberValue, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return NewCharacterTypesValueUnknown(), diags
	}

	return CharacterTypesValue{
		Min:   minVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCharacterTypesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CharacterTypesValue {
	object, diags := NewCharacterTypesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCharacterTypesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CharacterTypesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCharacterTypesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCharacterTypesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCharacterTypesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCharacterTypesValueMust(CharacterTypesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CharacterTypesType) ValueType(ctx context.Context) attr.Value {
	return CharacterTypesValue{}
}

var _ basetypes.ObjectValuable = CharacterTypesValue{}

type CharacterTypesValue struct {
	Min   basetypes.NumberValue `tfsdk:"min"`
	state attr.ValueState
}

func (v CharacterTypesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["min"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CharacterTypesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CharacterTypesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CharacterTypesValue) String() string {
	return "CharacterTypesValue"
}

func (v CharacterTypesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"min": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"min": v.Min,
		})

	return objVal, diags
}

func (v CharacterTypesValue) Equal(o attr.Value) bool {
	other, ok := o.(CharacterTypesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	return true
}

func (v CharacterTypesValue) Type(ctx context.Context) attr.Type {
	return CharacterTypesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CharacterTypesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"min": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = LengthType{}

type LengthType struct {
	basetypes.ObjectType
}

func (t LengthType) Equal(o attr.Type) bool {
	other, ok := o.(LengthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LengthType) String() string {
	return "LengthType"
}

func (t LengthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.NumberValue, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.NumberValue, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LengthValue{
		Max:   maxVal,
		Min:   minVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLengthValueNull() LengthValue {
	return LengthValue{
		state: attr.ValueStateNull,
	}
}

func NewLengthValueUnknown() LengthValue {
	return LengthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLengthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LengthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LengthValue Attribute Value",
				"While creating a LengthValue value, a missing attribute value was detected. "+
					"A LengthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LengthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LengthValue Attribute Type",
				"While creating a LengthValue value, an invalid attribute value was detected. "+
					"A LengthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LengthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LengthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LengthValue Attribute Value",
				"While creating a LengthValue value, an extra attribute value was detected. "+
					"A LengthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LengthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLengthValueUnknown(), diags
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewLengthValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.NumberValue, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewLengthValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.NumberValue, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return NewLengthValueUnknown(), diags
	}

	return LengthValue{
		Max:   maxVal,
		Min:   minVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLengthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LengthValue {
	object, diags := NewLengthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLengthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LengthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLengthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLengthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLengthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLengthValueMust(LengthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LengthType) ValueType(ctx context.Context) attr.Value {
	return LengthValue{}
}

var _ basetypes.ObjectValuable = LengthValue{}

type LengthValue struct {
	Max   basetypes.NumberValue `tfsdk:"max"`
	Min   basetypes.NumberValue `tfsdk:"min"`
	state attr.ValueState
}

func (v LengthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LengthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LengthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LengthValue) String() string {
	return "LengthValue"
}

func (v LengthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max": basetypes.NumberType{},
		"min": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max": v.Max,
			"min": v.Min,
		})

	return objVal, diags
}

func (v LengthValue) Equal(o attr.Value) bool {
	other, ok := o.(LengthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	return true
}

func (v LengthValue) Type(ctx context.Context) attr.Type {
	return LengthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LengthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max": basetypes.NumberType{},
		"min": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = RejectsType{}

type RejectsType struct {
	basetypes.ObjectType
}

func (t RejectsType) Equal(o attr.Type) bool {
	other, ok := o.(RejectsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RejectsType) String() string {
	return "RejectsType"
}

func (t RejectsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pwnedAttribute, ok := attributes["pwned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pwned is missing from object`)

		return nil, diags
	}

	pwnedVal, ok := pwnedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pwned expected to be basetypes.BoolValue, was: %T`, pwnedAttribute))
	}

	repetitionAndSequenceAttribute, ok := attributes["repetition_and_sequence"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repetition_and_sequence is missing from object`)

		return nil, diags
	}

	repetitionAndSequenceVal, ok := repetitionAndSequenceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repetition_and_sequence expected to be basetypes.BoolValue, was: %T`, repetitionAndSequenceAttribute))
	}

	userInfoAttribute, ok := attributes["user_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_info is missing from object`)

		return nil, diags
	}

	userInfoVal, ok := userInfoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_info expected to be basetypes.BoolValue, was: %T`, userInfoAttribute))
	}

	wordsAttribute, ok := attributes["words"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`words is missing from object`)

		return nil, diags
	}

	wordsVal, ok := wordsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`words expected to be basetypes.ListValue, was: %T`, wordsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RejectsValue{
		Pwned:                 pwnedVal,
		RepetitionAndSequence: repetitionAndSequenceVal,
		UserInfo:              userInfoVal,
		Words:                 wordsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewRejectsValueNull() RejectsValue {
	return RejectsValue{
		state: attr.ValueStateNull,
	}
}

func NewRejectsValueUnknown() RejectsValue {
	return RejectsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRejectsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RejectsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RejectsValue Attribute Value",
				"While creating a RejectsValue value, a missing attribute value was detected. "+
					"A RejectsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RejectsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RejectsValue Attribute Type",
				"While creating a RejectsValue value, an invalid attribute value was detected. "+
					"A RejectsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RejectsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RejectsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RejectsValue Attribute Value",
				"While creating a RejectsValue value, an extra attribute value was detected. "+
					"A RejectsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RejectsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRejectsValueUnknown(), diags
	}

	pwnedAttribute, ok := attributes["pwned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pwned is missing from object`)

		return NewRejectsValueUnknown(), diags
	}

	pwnedVal, ok := pwnedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pwned expected to be basetypes.BoolValue, was: %T`, pwnedAttribute))
	}

	repetitionAndSequenceAttribute, ok := attributes["repetition_and_sequence"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repetition_and_sequence is missing from object`)

		return NewRejectsValueUnknown(), diags
	}

	repetitionAndSequenceVal, ok := repetitionAndSequenceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repetition_and_sequence expected to be basetypes.BoolValue, was: %T`, repetitionAndSequenceAttribute))
	}

	userInfoAttribute, ok := attributes["user_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_info is missing from object`)

		return NewRejectsValueUnknown(), diags
	}

	userInfoVal, ok := userInfoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_info expected to be basetypes.BoolValue, was: %T`, userInfoAttribute))
	}

	wordsAttribute, ok := attributes["words"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`words is missing from object`)

		return NewRejectsValueUnknown(), diags
	}

	wordsVal, ok := wordsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`words expected to be basetypes.ListValue, was: %T`, wordsAttribute))
	}

	if diags.HasError() {
		return NewRejectsValueUnknown(), diags
	}

	return RejectsValue{
		Pwned:                 pwnedVal,
		RepetitionAndSequence: repetitionAndSequenceVal,
		UserInfo:              userInfoVal,
		Words:                 wordsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewRejectsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RejectsValue {
	object, diags := NewRejectsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRejectsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RejectsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRejectsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRejectsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRejectsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRejectsValueMust(RejectsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RejectsType) ValueType(ctx context.Context) attr.Value {
	return RejectsValue{}
}

var _ basetypes.ObjectValuable = RejectsValue{}

type RejectsValue struct {
	Pwned                 basetypes.BoolValue `tfsdk:"pwned"`
	RepetitionAndSequence basetypes.BoolValue `tfsdk:"repetition_and_sequence"`
	UserInfo              basetypes.BoolValue `tfsdk:"user_info"`
	Words                 basetypes.ListValue `tfsdk:"words"`
	state                 attr.ValueState
}

func (v RejectsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["pwned"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["repetition_and_sequence"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["user_info"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["words"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Pwned.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pwned"] = val

		val, err = v.RepetitionAndSequence.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["repetition_and_sequence"] = val

		val, err = v.UserInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_info"] = val

		val, err = v.Words.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["words"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RejectsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RejectsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RejectsValue) String() string {
	return "RejectsValue"
}

func (v RejectsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var wordsVal basetypes.ListValue
	switch {
	case v.Words.IsUnknown():
		wordsVal = types.ListUnknown(types.StringType)
	case v.Words.IsNull():
		wordsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wordsVal, d = types.ListValue(types.StringType, v.Words.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"pwned":                   basetypes.BoolType{},
			"repetition_and_sequence": basetypes.BoolType{},
			"user_info":               basetypes.BoolType{},
			"words": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"pwned":                   basetypes.BoolType{},
		"repetition_and_sequence": basetypes.BoolType{},
		"user_info":               basetypes.BoolType{},
		"words": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"pwned":                   v.Pwned,
			"repetition_and_sequence": v.RepetitionAndSequence,
			"user_info":               v.UserInfo,
			"words":                   wordsVal,
		})

	return objVal, diags
}

func (v RejectsValue) Equal(o attr.Value) bool {
	other, ok := o.(RejectsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Pwned.Equal(other.Pwned) {
		return false
	}

	if !v.RepetitionAndSequence.Equal(other.RepetitionAndSequence) {
		return false
	}

	if !v.UserInfo.Equal(other.UserInfo) {
		return false
	}

	if !v.Words.Equal(other.Words) {
		return false
	}

	return true
}

func (v RejectsValue) Type(ctx context.Context) attr.Type {
	return RejectsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RejectsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"pwned":                   basetypes.BoolType{},
		"repetition_and_sequence": basetypes.BoolType{},
		"user_info":               basetypes.BoolType{},
		"words": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SentinelPolicyType{}

type SentinelPolicyType struct {
	basetypes.ObjectType
}

func (t SentinelPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(SentinelPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SentinelPolicyType) String() string {
	return "SentinelPolicyType"
}

func (t SentinelPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lockoutDurationAttribute, ok := attributes["lockout_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lockout_duration is missing from object`)

		return nil, diags
	}

	lockoutDurationVal, ok := lockoutDurationAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lockout_duration expected to be basetypes.NumberValue, was: %T`, lockoutDurationAttribute))
	}

	maxAttemptsAttribute, ok := attributes["max_attempts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_attempts is missing from object`)

		return nil, diags
	}

	maxAttemptsVal, ok := maxAttemptsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_attempts expected to be basetypes.NumberValue, was: %T`, maxAttemptsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SentinelPolicyValue{
		LockoutDuration: lockoutDurationVal,
		MaxAttempts:     maxAttemptsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSentinelPolicyValueNull() SentinelPolicyValue {
	return SentinelPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewSentinelPolicyValueUnknown() SentinelPolicyValue {
	return SentinelPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSentinelPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SentinelPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SentinelPolicyValue Attribute Value",
				"While creating a SentinelPolicyValue value, a missing attribute value was detected. "+
					"A SentinelPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SentinelPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SentinelPolicyValue Attribute Type",
				"While creating a SentinelPolicyValue value, an invalid attribute value was detected. "+
					"A SentinelPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SentinelPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SentinelPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SentinelPolicyValue Attribute Value",
				"While creating a SentinelPolicyValue value, an extra attribute value was detected. "+
					"A SentinelPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SentinelPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSentinelPolicyValueUnknown(), diags
	}

	lockoutDurationAttribute, ok := attributes["lockout_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lockout_duration is missing from object`)

		return NewSentinelPolicyValueUnknown(), diags
	}

	lockoutDurationVal, ok := lockoutDurationAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lockout_duration expected to be basetypes.NumberValue, was: %T`, lockoutDurationAttribute))
	}

	maxAttemptsAttribute, ok := attributes["max_attempts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_attempts is missing from object`)

		return NewSentinelPolicyValueUnknown(), diags
	}

	maxAttemptsVal, ok := maxAttemptsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_attempts expected to be basetypes.NumberValue, was: %T`, maxAttemptsAttribute))
	}

	if diags.HasError() {
		return NewSentinelPolicyValueUnknown(), diags
	}

	return SentinelPolicyValue{
		LockoutDuration: lockoutDurationVal,
		MaxAttempts:     maxAttemptsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSentinelPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SentinelPolicyValue {
	object, diags := NewSentinelPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSentinelPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SentinelPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSentinelPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSentinelPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSentinelPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSentinelPolicyValueMust(SentinelPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SentinelPolicyType) ValueType(ctx context.Context) attr.Value {
	return SentinelPolicyValue{}
}

var _ basetypes.ObjectValuable = SentinelPolicyValue{}

type SentinelPolicyValue struct {
	LockoutDuration basetypes.NumberValue `tfsdk:"lockout_duration"`
	MaxAttempts     basetypes.NumberValue `tfsdk:"max_attempts"`
	state           attr.ValueState
}

func (v SentinelPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["lockout_duration"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["max_attempts"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LockoutDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lockout_duration"] = val

		val, err = v.MaxAttempts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_attempts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SentinelPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SentinelPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SentinelPolicyValue) String() string {
	return "SentinelPolicyValue"
}

func (v SentinelPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"lockout_duration": basetypes.NumberType{},
		"max_attempts":     basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lockout_duration": v.LockoutDuration,
			"max_attempts":     v.MaxAttempts,
		})

	return objVal, diags
}

func (v SentinelPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(SentinelPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LockoutDuration.Equal(other.LockoutDuration) {
		return false
	}

	if !v.MaxAttempts.Equal(other.MaxAttempts) {
		return false
	}

	return true
}

func (v SentinelPolicyValue) Type(ctx context.Context) attr.Type {
	return SentinelPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SentinelPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lockout_duration": basetypes.NumberType{},
		"max_attempts":     basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = SignInType{}

type SignInType struct {
	basetypes.ObjectType
}

func (t SignInType) Equal(o attr.Type) bool {
	other, ok := o.(SignInType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SignInType) String() string {
	return "SignInType"
}

func (t SignInType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	methodsAttribute, ok := attributes["methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`methods is missing from object`)

		return nil, diags
	}

	methodsVal, ok := methodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`methods expected to be basetypes.ListValue, was: %T`, methodsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SignInValue{
		Methods: methodsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSignInValueNull() SignInValue {
	return SignInValue{
		state: attr.ValueStateNull,
	}
}

func NewSignInValueUnknown() SignInValue {
	return SignInValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSignInValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SignInValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SignInValue Attribute Value",
				"While creating a SignInValue value, a missing attribute value was detected. "+
					"A SignInValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SignInValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SignInValue Attribute Type",
				"While creating a SignInValue value, an invalid attribute value was detected. "+
					"A SignInValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SignInValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SignInValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SignInValue Attribute Value",
				"While creating a SignInValue value, an extra attribute value was detected. "+
					"A SignInValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SignInValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSignInValueUnknown(), diags
	}

	methodsAttribute, ok := attributes["methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`methods is missing from object`)

		return NewSignInValueUnknown(), diags
	}

	methodsVal, ok := methodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`methods expected to be basetypes.ListValue, was: %T`, methodsAttribute))
	}

	if diags.HasError() {
		return NewSignInValueUnknown(), diags
	}

	return SignInValue{
		Methods: methodsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSignInValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SignInValue {
	object, diags := NewSignInValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSignInValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SignInType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSignInValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSignInValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSignInValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSignInValueMust(SignInValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SignInType) ValueType(ctx context.Context) attr.Value {
	return SignInValue{}
}

var _ basetypes.ObjectValuable = SignInValue{}

type SignInValue struct {
	Methods basetypes.ListValue `tfsdk:"methods"`
	state   attr.ValueState
}

func (v SignInValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["methods"] = basetypes.ListType{
		ElemType: MethodsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Methods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["methods"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SignInValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SignInValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SignInValue) String() string {
	return "SignInValue"
}

func (v SignInValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	methods := types.ListValueMust(
		MethodsType{
			basetypes.ObjectType{
				AttrTypes: MethodsValue{}.AttributeTypes(ctx),
			},
		},
		v.Methods.Elements(),
	)

	if v.Methods.IsNull() {
		methods = types.ListNull(
			MethodsType{
				basetypes.ObjectType{
					AttrTypes: MethodsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Methods.IsUnknown() {
		methods = types.ListUnknown(
			MethodsType{
				basetypes.ObjectType{
					AttrTypes: MethodsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"methods": basetypes.ListType{
			ElemType: MethodsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"methods": methods,
		})

	return objVal, diags
}

func (v SignInValue) Equal(o attr.Value) bool {
	other, ok := o.(SignInValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Methods.Equal(other.Methods) {
		return false
	}

	return true
}

func (v SignInValue) Type(ctx context.Context) attr.Type {
	return SignInType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SignInValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"methods": basetypes.ListType{
			ElemType: MethodsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MethodsType{}

type MethodsType struct {
	basetypes.ObjectType
}

func (t MethodsType) Equal(o attr.Type) bool {
	other, ok := o.(MethodsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MethodsType) String() string {
	return "MethodsType"
}

func (t MethodsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return nil, diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	isPasswordPrimaryAttribute, ok := attributes["is_password_primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_password_primary is missing from object`)

		return nil, diags
	}

	isPasswordPrimaryVal, ok := isPasswordPrimaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_password_primary expected to be basetypes.BoolValue, was: %T`, isPasswordPrimaryAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.BoolValue, was: %T`, passwordAttribute))
	}

	verificationCodeAttribute, ok := attributes["verification_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_code is missing from object`)

		return nil, diags
	}

	verificationCodeVal, ok := verificationCodeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_code expected to be basetypes.BoolValue, was: %T`, verificationCodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MethodsValue{
		Identifier:        identifierVal,
		IsPasswordPrimary: isPasswordPrimaryVal,
		Password:          passwordVal,
		VerificationCode:  verificationCodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewMethodsValueNull() MethodsValue {
	return MethodsValue{
		state: attr.ValueStateNull,
	}
}

func NewMethodsValueUnknown() MethodsValue {
	return MethodsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMethodsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MethodsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MethodsValue Attribute Value",
				"While creating a MethodsValue value, a missing attribute value was detected. "+
					"A MethodsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MethodsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MethodsValue Attribute Type",
				"While creating a MethodsValue value, an invalid attribute value was detected. "+
					"A MethodsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MethodsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MethodsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MethodsValue Attribute Value",
				"While creating a MethodsValue value, an extra attribute value was detected. "+
					"A MethodsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MethodsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMethodsValueUnknown(), diags
	}

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return NewMethodsValueUnknown(), diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	isPasswordPrimaryAttribute, ok := attributes["is_password_primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_password_primary is missing from object`)

		return NewMethodsValueUnknown(), diags
	}

	isPasswordPrimaryVal, ok := isPasswordPrimaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_password_primary expected to be basetypes.BoolValue, was: %T`, isPasswordPrimaryAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewMethodsValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.BoolValue, was: %T`, passwordAttribute))
	}

	verificationCodeAttribute, ok := attributes["verification_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_code is missing from object`)

		return NewMethodsValueUnknown(), diags
	}

	verificationCodeVal, ok := verificationCodeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_code expected to be basetypes.BoolValue, was: %T`, verificationCodeAttribute))
	}

	if diags.HasError() {
		return NewMethodsValueUnknown(), diags
	}

	return MethodsValue{
		Identifier:        identifierVal,
		IsPasswordPrimary: isPasswordPrimaryVal,
		Password:          passwordVal,
		VerificationCode:  verificationCodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewMethodsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MethodsValue {
	object, diags := NewMethodsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMethodsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MethodsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMethodsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMethodsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMethodsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMethodsValueMust(MethodsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MethodsType) ValueType(ctx context.Context) attr.Value {
	return MethodsValue{}
}

var _ basetypes.ObjectValuable = MethodsValue{}

type MethodsValue struct {
	Identifier        basetypes.StringValue `tfsdk:"identifier"`
	IsPasswordPrimary basetypes.BoolValue   `tfsdk:"is_password_primary"`
	Password          basetypes.BoolValue   `tfsdk:"password"`
	VerificationCode  basetypes.BoolValue   `tfsdk:"verification_code"`
	state             attr.ValueState
}

func (v MethodsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["identifier"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_password_primary"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["verification_code"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Identifier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identifier"] = val

		val, err = v.IsPasswordPrimary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_password_primary"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.VerificationCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verification_code"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MethodsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MethodsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MethodsValue) String() string {
	return "MethodsValue"
}

func (v MethodsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"identifier":          basetypes.StringType{},
		"is_password_primary": basetypes.BoolType{},
		"password":            basetypes.BoolType{},
		"verification_code":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"identifier":          v.Identifier,
			"is_password_primary": v.IsPasswordPrimary,
			"password":            v.Password,
			"verification_code":   v.VerificationCode,
		})

	return objVal, diags
}

func (v MethodsValue) Equal(o attr.Value) bool {
	other, ok := o.(MethodsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Identifier.Equal(other.Identifier) {
		return false
	}

	if !v.IsPasswordPrimary.Equal(other.IsPasswordPrimary) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.VerificationCode.Equal(other.VerificationCode) {
		return false
	}

	return true
}

func (v MethodsValue) Type(ctx context.Context) attr.Type {
	return MethodsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MethodsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"identifier":          basetypes.StringType{},
		"is_password_primary": basetypes.BoolType{},
		"password":            basetypes.BoolType{},
		"verification_code":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SignUpType{}

type SignUpType struct {
	basetypes.ObjectType
}

func (t SignUpType) Equal(o attr.Type) bool {
	other, ok := o.(SignUpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SignUpType) String() string {
	return "SignUpType"
}

func (t SignUpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	identifiersAttribute, ok := attributes["identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifiers is missing from object`)

		return nil, diags
	}

	identifiersVal, ok := identifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifiers expected to be basetypes.ListValue, was: %T`, identifiersAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.BoolValue, was: %T`, passwordAttribute))
	}

	secondaryIdentifiersAttribute, ok := attributes["secondary_identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_identifiers is missing from object`)

		return nil, diags
	}

	secondaryIdentifiersVal, ok := secondaryIdentifiersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_identifiers expected to be basetypes.ObjectValue, was: %T`, secondaryIdentifiersAttribute))
	}

	verifyAttribute, ok := attributes["verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify is missing from object`)

		return nil, diags
	}

	verifyVal, ok := verifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify expected to be basetypes.BoolValue, was: %T`, verifyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SignUpValue{
		Identifiers:          identifiersVal,
		Password:             passwordVal,
		SecondaryIdentifiers: secondaryIdentifiersVal,
		Verify:               verifyVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewSignUpValueNull() SignUpValue {
	return SignUpValue{
		state: attr.ValueStateNull,
	}
}

func NewSignUpValueUnknown() SignUpValue {
	return SignUpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSignUpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SignUpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SignUpValue Attribute Value",
				"While creating a SignUpValue value, a missing attribute value was detected. "+
					"A SignUpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SignUpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SignUpValue Attribute Type",
				"While creating a SignUpValue value, an invalid attribute value was detected. "+
					"A SignUpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SignUpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SignUpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SignUpValue Attribute Value",
				"While creating a SignUpValue value, an extra attribute value was detected. "+
					"A SignUpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SignUpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSignUpValueUnknown(), diags
	}

	identifiersAttribute, ok := attributes["identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifiers is missing from object`)

		return NewSignUpValueUnknown(), diags
	}

	identifiersVal, ok := identifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifiers expected to be basetypes.ListValue, was: %T`, identifiersAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewSignUpValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.BoolValue, was: %T`, passwordAttribute))
	}

	secondaryIdentifiersAttribute, ok := attributes["secondary_identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_identifiers is missing from object`)

		return NewSignUpValueUnknown(), diags
	}

	secondaryIdentifiersVal, ok := secondaryIdentifiersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_identifiers expected to be basetypes.ObjectValue, was: %T`, secondaryIdentifiersAttribute))
	}

	verifyAttribute, ok := attributes["verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify is missing from object`)

		return NewSignUpValueUnknown(), diags
	}

	verifyVal, ok := verifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify expected to be basetypes.BoolValue, was: %T`, verifyAttribute))
	}

	if diags.HasError() {
		return NewSignUpValueUnknown(), diags
	}

	return SignUpValue{
		Identifiers:          identifiersVal,
		Password:             passwordVal,
		SecondaryIdentifiers: secondaryIdentifiersVal,
		Verify:               verifyVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewSignUpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SignUpValue {
	object, diags := NewSignUpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSignUpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SignUpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSignUpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSignUpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSignUpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSignUpValueMust(SignUpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SignUpType) ValueType(ctx context.Context) attr.Value {
	return SignUpValue{}
}

var _ basetypes.ObjectValuable = SignUpValue{}

type SignUpValue struct {
	Identifiers          basetypes.ListValue   `tfsdk:"identifiers"`
	Password             basetypes.BoolValue   `tfsdk:"password"`
	SecondaryIdentifiers basetypes.ObjectValue `tfsdk:"secondary_identifiers"`
	Verify               basetypes.BoolValue   `tfsdk:"verify"`
	state                attr.ValueState
}

func (v SignUpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["identifiers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["password"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["secondary_identifiers"] = basetypes.ObjectType{
		AttrTypes: SecondaryIdentifiersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["verify"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Identifiers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identifiers"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.SecondaryIdentifiers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_identifiers"] = val

		val, err = v.Verify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SignUpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SignUpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SignUpValue) String() string {
	return "SignUpValue"
}

func (v SignUpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var secondaryIdentifiers basetypes.ObjectValue

	if v.SecondaryIdentifiers.IsNull() {
		secondaryIdentifiers = types.ObjectNull(
			SecondaryIdentifiersValue{}.AttributeTypes(ctx),
		)
	}

	if v.SecondaryIdentifiers.IsUnknown() {
		secondaryIdentifiers = types.ObjectUnknown(
			SecondaryIdentifiersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SecondaryIdentifiers.IsNull() && !v.SecondaryIdentifiers.IsUnknown() {
		secondaryIdentifiers = types.ObjectValueMust(
			SecondaryIdentifiersValue{}.AttributeTypes(ctx),
			v.SecondaryIdentifiers.Attributes(),
		)
	}

	var identifiersVal basetypes.ListValue
	switch {
	case v.Identifiers.IsUnknown():
		identifiersVal = types.ListUnknown(types.StringType)
	case v.Identifiers.IsNull():
		identifiersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		identifiersVal, d = types.ListValue(types.StringType, v.Identifiers.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"identifiers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"password": basetypes.BoolType{},
			"secondary_identifiers": basetypes.ObjectType{
				AttrTypes: SecondaryIdentifiersValue{}.AttributeTypes(ctx),
			},
			"verify": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"identifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"password": basetypes.BoolType{},
		"secondary_identifiers": basetypes.ObjectType{
			AttrTypes: SecondaryIdentifiersValue{}.AttributeTypes(ctx),
		},
		"verify": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"identifiers":           identifiersVal,
			"password":              v.Password,
			"secondary_identifiers": secondaryIdentifiers,
			"verify":                v.Verify,
		})

	return objVal, diags
}

func (v SignUpValue) Equal(o attr.Value) bool {
	other, ok := o.(SignUpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Identifiers.Equal(other.Identifiers) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.SecondaryIdentifiers.Equal(other.SecondaryIdentifiers) {
		return false
	}

	if !v.Verify.Equal(other.Verify) {
		return false
	}

	return true
}

func (v SignUpValue) Type(ctx context.Context) attr.Type {
	return SignUpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SignUpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"identifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"password": basetypes.BoolType{},
		"secondary_identifiers": basetypes.ObjectType{
			AttrTypes: SecondaryIdentifiersValue{}.AttributeTypes(ctx),
		},
		"verify": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SecondaryIdentifiersType{}

type SecondaryIdentifiersType struct {
	basetypes.ObjectType
}

func (t SecondaryIdentifiersType) Equal(o attr.Type) bool {
	other, ok := o.(SecondaryIdentifiersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecondaryIdentifiersType) String() string {
	return "SecondaryIdentifiersType"
}

func (t SecondaryIdentifiersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return nil, diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	verifyAttribute, ok := attributes["verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify is missing from object`)

		return nil, diags
	}

	verifyVal, ok := verifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify expected to be basetypes.BoolValue, was: %T`, verifyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecondaryIdentifiersValue{
		Identifier: identifierVal,
		Verify:     verifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecondaryIdentifiersValueNull() SecondaryIdentifiersValue {
	return SecondaryIdentifiersValue{
		state: attr.ValueStateNull,
	}
}

func NewSecondaryIdentifiersValueUnknown() SecondaryIdentifiersValue {
	return SecondaryIdentifiersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecondaryIdentifiersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecondaryIdentifiersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecondaryIdentifiersValue Attribute Value",
				"While creating a SecondaryIdentifiersValue value, a missing attribute value was detected. "+
					"A SecondaryIdentifiersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryIdentifiersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecondaryIdentifiersValue Attribute Type",
				"While creating a SecondaryIdentifiersValue value, an invalid attribute value was detected. "+
					"A SecondaryIdentifiersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryIdentifiersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecondaryIdentifiersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecondaryIdentifiersValue Attribute Value",
				"While creating a SecondaryIdentifiersValue value, an extra attribute value was detected. "+
					"A SecondaryIdentifiersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecondaryIdentifiersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecondaryIdentifiersValueUnknown(), diags
	}

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return NewSecondaryIdentifiersValueUnknown(), diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	verifyAttribute, ok := attributes["verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify is missing from object`)

		return NewSecondaryIdentifiersValueUnknown(), diags
	}

	verifyVal, ok := verifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify expected to be basetypes.BoolValue, was: %T`, verifyAttribute))
	}

	if diags.HasError() {
		return NewSecondaryIdentifiersValueUnknown(), diags
	}

	return SecondaryIdentifiersValue{
		Identifier: identifierVal,
		Verify:     verifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecondaryIdentifiersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecondaryIdentifiersValue {
	object, diags := NewSecondaryIdentifiersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecondaryIdentifiersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecondaryIdentifiersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecondaryIdentifiersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecondaryIdentifiersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecondaryIdentifiersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecondaryIdentifiersValueMust(SecondaryIdentifiersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecondaryIdentifiersType) ValueType(ctx context.Context) attr.Value {
	return SecondaryIdentifiersValue{}
}

var _ basetypes.ObjectValuable = SecondaryIdentifiersValue{}

type SecondaryIdentifiersValue struct {
	Identifier basetypes.StringValue `tfsdk:"identifier"`
	Verify     basetypes.BoolValue   `tfsdk:"verify"`
	state      attr.ValueState
}

func (v SecondaryIdentifiersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["identifier"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verify"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Identifier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identifier"] = val

		val, err = v.Verify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecondaryIdentifiersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecondaryIdentifiersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecondaryIdentifiersValue) String() string {
	return "SecondaryIdentifiersValue"
}

func (v SecondaryIdentifiersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"identifier": basetypes.StringType{},
		"verify":     basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"identifier": v.Identifier,
			"verify":     v.Verify,
		})

	return objVal, diags
}

func (v SecondaryIdentifiersValue) Equal(o attr.Value) bool {
	other, ok := o.(SecondaryIdentifiersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Identifier.Equal(other.Identifier) {
		return false
	}

	if !v.Verify.Equal(other.Verify) {
		return false
	}

	return true
}

func (v SecondaryIdentifiersValue) Type(ctx context.Context) attr.Type {
	return SecondaryIdentifiersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecondaryIdentifiersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"identifier": basetypes.StringType{},
		"verify":     basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SocialSignInType{}

type SocialSignInType struct {
	basetypes.ObjectType
}

func (t SocialSignInType) Equal(o attr.Type) bool {
	other, ok := o.(SocialSignInType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SocialSignInType) String() string {
	return "SocialSignInType"
}

func (t SocialSignInType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	automaticAccountLinkingAttribute, ok := attributes["automatic_account_linking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic_account_linking is missing from object`)

		return nil, diags
	}

	automaticAccountLinkingVal, ok := automaticAccountLinkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic_account_linking expected to be basetypes.BoolValue, was: %T`, automaticAccountLinkingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SocialSignInValue{
		AutomaticAccountLinking: automaticAccountLinkingVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSocialSignInValueNull() SocialSignInValue {
	return SocialSignInValue{
		state: attr.ValueStateNull,
	}
}

func NewSocialSignInValueUnknown() SocialSignInValue {
	return SocialSignInValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSocialSignInValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SocialSignInValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SocialSignInValue Attribute Value",
				"While creating a SocialSignInValue value, a missing attribute value was detected. "+
					"A SocialSignInValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SocialSignInValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SocialSignInValue Attribute Type",
				"While creating a SocialSignInValue value, an invalid attribute value was detected. "+
					"A SocialSignInValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SocialSignInValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SocialSignInValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SocialSignInValue Attribute Value",
				"While creating a SocialSignInValue value, an extra attribute value was detected. "+
					"A SocialSignInValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SocialSignInValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSocialSignInValueUnknown(), diags
	}

	automaticAccountLinkingAttribute, ok := attributes["automatic_account_linking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic_account_linking is missing from object`)

		return NewSocialSignInValueUnknown(), diags
	}

	automaticAccountLinkingVal, ok := automaticAccountLinkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic_account_linking expected to be basetypes.BoolValue, was: %T`, automaticAccountLinkingAttribute))
	}

	if diags.HasError() {
		return NewSocialSignInValueUnknown(), diags
	}

	return SocialSignInValue{
		AutomaticAccountLinking: automaticAccountLinkingVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSocialSignInValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SocialSignInValue {
	object, diags := NewSocialSignInValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSocialSignInValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SocialSignInType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSocialSignInValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSocialSignInValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSocialSignInValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSocialSignInValueMust(SocialSignInValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SocialSignInType) ValueType(ctx context.Context) attr.Value {
	return SocialSignInValue{}
}

var _ basetypes.ObjectValuable = SocialSignInValue{}

type SocialSignInValue struct {
	AutomaticAccountLinking basetypes.BoolValue `tfsdk:"automatic_account_linking"`
	state                   attr.ValueState
}

func (v SocialSignInValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["automatic_account_linking"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutomaticAccountLinking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["automatic_account_linking"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SocialSignInValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SocialSignInValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SocialSignInValue) String() string {
	return "SocialSignInValue"
}

func (v SocialSignInValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"automatic_account_linking": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"automatic_account_linking": v.AutomaticAccountLinking,
		})

	return objVal, diags
}

func (v SocialSignInValue) Equal(o attr.Value) bool {
	other, ok := o.(SocialSignInValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutomaticAccountLinking.Equal(other.AutomaticAccountLinking) {
		return false
	}

	return true
}

func (v SocialSignInValue) Type(ctx context.Context) attr.Type {
	return SocialSignInType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SocialSignInValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"automatic_account_linking": basetypes.BoolType{},
	}
}
