package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"unicode"

	"os/exec"

	tfgen "github.com/Lenstra/terraform-provider-logto/scripts/terraform-generator"
)

func main() {
	err := Main()
	if err != nil {
		log.Fatalf("err: %v", err)
	}
}

func Main() error {
	ctx := context.Background()
	spec, extra, err := tfgen.Load(ctx)
	if err != nil {
		return err
	}

	tfgen.Update(spec, extra)

	content, err := json.MarshalIndent(spec, "", "\t")
	if err != nil {
		return err
	}
	err = os.WriteFile("provider_code_spec.json", content, 0o644)
	if err != nil {
		return err
	}

	input := "provider_code_spec.json"
	output := "internal/provider"
	if err := generate(input, output); err != nil {
		return err
	}
	return generateAdditionalFiles(output)
}

func generate(input, output string) error {
	cmd := exec.Command(
		"tfplugingen-framework",
		"generate",
		"all",
		"--input="+input,
		"--output="+output,
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func generateAdditionalFiles(output string) error {
	entries, err := os.ReadDir(output)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() && strings.HasPrefix(entry.Name(), "resource_") {
			packageName := strings.TrimPrefix(entry.Name(), "resource_")
			resourceName := toCamelCase(packageName)
			path := fmt.Sprintf("internal/provider/%s/%s_resource_impl_gen.go", entry.Name(), packageName)
			content := []byte(template(packageName, resourceName))
			if err := os.WriteFile(path, content, 0o644); err != nil {
				return err
			}
		}
	}
	return nil
}

func template(packageName, resourceName string) string {

	return fmt.Sprintf(`// Code generated by terraform-generator DO NOT EDIT.
package resource_%[3]s

import (
	"context"

	"github.com/Lenstra/terraform-provider-logto/client"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource                = &%[1]sResource{}
	_ resource.ResourceWithConfigure   = &%[1]sResource{}
	_ resource.ResourceWithImportState = &%[1]sResource{}
)

type %[1]sResource struct {
	client *client.Client
}

func %[2]sResource() resource.Resource {
	return &%[1]sResource{}
}

func (r *%[1]sResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_%[1]s"
}

func (r *%[1]sResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = %[2]sResourceSchema(ctx)
}

func (r *%[1]sResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		return
	}
	r.client = client
}

func (r *%[1]sResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
`, resourceName, toPascalCase(packageName), packageName)
}

func toCamelCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || unicode.IsSpace(r)
	})

	for i, p := range parts {
		if len(p) > 0 {
			if i == 0 {
				parts[i] = strings.ToLower(p)
			} else {
				parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
			}
		}
	}
	return strings.Join(parts, "")
}

func toPascalCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || unicode.IsSpace(r)
	})
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}
	return strings.Join(parts, "")
}
